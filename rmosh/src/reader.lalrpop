use crate::objects::Object;
use crate::gc::Gc;
use crate::lexer;
use crate::objects::Bytevector;
use crate::reader_util::ReadError;
use crate::reader_util::count_lineno;
use crate::reader_util;
use lalrpop_util::ParseError;
use std::collections::HashMap;


grammar(gc: &mut Box<Gc>, shared_map: &mut HashMap<u32, Object>, input_src: &str, content: &str);

// R7RS small 7.1.2. External representations
pub Datum: Object = {
    SimpleDatum,
    CompoundDataum,
    "#;" Datum <datum: Datum> => datum,
    <idx: "#1="> <datum: Datum> => {
        let key = u32::from_str_radix(&idx, 10).unwrap();
        shared_map.insert(key, datum);
        datum
    },
    "#1#" => {
        Object::DefinedShared(u32::from_str_radix(&<>, 10).unwrap())
    }
}

CompoundDataum: Object = {
    List,
    Vector,
    Abbreviation,
}

SimpleDatum: Object = {
    Boolean,
    ByteVector,
    Character,
    Number,
    Regexp,
    String,
    Symbol,
}

List: Object = {
    <lo:@L> <left: "("> <objects: Datum *> <right: ")"> <ro:@R> =>? {
        if (left.eq("(") && right.eq(")")) || (left.eq("[") && right.eq("]")) {
            let file = gc.new_string(input_src);
            let lineno = count_lineno(content, lo);
            let src = gc.list2(file, Object::Fixnum(lineno as isize));
            Ok(gc.listn_src(&objects, src))
        } else {
            Err(ParseError::User {
                error:ReadError::UnmatchedParen { start:lo, end:ro, token:left }})            
        }
    },
    <lo:@L> <left: "("> <objects: Datum *> "#;" Datum <right: ")"> <ro:@R> =>? {
        if (left.eq("(") && right.eq(")")) || (left.eq("[") && right.eq("]")) {        
            let file = gc.new_string(input_src);
            let lineno = count_lineno(content, lo);        
            let src = gc.list2(file, Object::Fixnum(lineno as isize));
            Ok(gc.listn_src(&objects, src))
        } else {
            Err(ParseError::User {
                error:ReadError::UnmatchedParen { start:lo, end:ro, token:left }})            
        }        
    },
    // TODO: There should be a better way to skip datum comment.
    <lo:@L> <left: "("> <objects: Datum *> "#;" Datum "#;" Datum  <right: ")"> <ro:@R> =>? {
        if (left.eq("(") && right.eq(")")) || (left.eq("[") && right.eq("]")) {          
            let file = gc.new_string(input_src);
            let lineno = count_lineno(content, lo);        
            let src = gc.list2(file, Object::Fixnum(lineno as isize));
            Ok(gc.listn_src(&objects, src))
        } else {
            Err(ParseError::User {
                error:ReadError::UnmatchedParen { start:lo, end:ro, token:left }})            
        }          
    },
    <lo:@L> <left: "("> <objects: Datum *> "#;" Datum "#;" Datum "#;" Datum  <right: ")"> <ro:@R> =>? {
        if (left.eq("(") && right.eq(")")) || (left.eq("[") && right.eq("]")) {          
            let file = gc.new_string(input_src);
            let lineno = count_lineno(content, lo);        
            let src = gc.list2(file, Object::Fixnum(lineno as isize));
            Ok(gc.listn_src(&objects, src))
        } else {
            Err(ParseError::User {
                error:ReadError::UnmatchedParen { start:lo, end:ro, token:left }})            
        }          
    },
    <lo:@L> <left: "("> <objects: Datum +> "." <last: Datum> "#;" Datum  <right: ")"> <ro:@R> =>? {
        if (left.eq("(") && right.eq(")")) || (left.eq("[") && right.eq("]")) {  
            let file = gc.new_string(input_src);
            let lineno = count_lineno(content, lo);        
            let src = gc.list2(file, Object::Fixnum(lineno as isize));
            Ok(gc.dot_pair_src(&objects, last, src))
        } else {
            Err(ParseError::User {
                error:ReadError::UnmatchedParen { start:lo, end:ro, token:left }})            
        }          
    },
    <lo:@L> <left: "("> <objects: Datum +> "." <last: Datum>  <right: ")"> <ro:@R> =>? {
        if (left.eq("(") && right.eq(")")) || (left.eq("[") && right.eq("]")) {  
            let file = gc.new_string(input_src);
            let lineno = count_lineno(content, lo);        
            let src = gc.list2(file, Object::Fixnum(lineno as isize));
            Ok(gc.dot_pair_src(&objects, last, src))
        } else {
            Err(ParseError::User {
                error:ReadError::UnmatchedParen { start:lo, end:ro, token:left }})            
        }          
    }
}

ByteVector: Object = {
    <lo:@L> <left: "#u8("> <objects: Datum *>  <right: ")"> <ro:@R> =>? {
        if (left.eq("#u8(") && right.eq(")")) || (left.eq("#u8[") && right.eq("]")) ||
           (left.eq("#vu8(") && right.eq(")")) || (left.eq("#vu8[") && right.eq("]")) {          
            let mut u8_vec: Vec<u8> = vec![];        
            for obj in objects {
                if let Object::Fixnum(n) = obj {
                    if n >= 0 && n <= 255 {
                        u8_vec.push(n as u8);            
                    } else {
                        return Err(ParseError::User {
                            error:ReadError::MalformedBytevector { start:0, end:0, token:"hige".to_string() }})
                    }
            }}
            let bv = gc.alloc(Bytevector::new(&u8_vec));
            Ok(Object::Bytevector(bv))
    } else {
        Err(ParseError::User {
            error:ReadError::UnmatchedParen { start:lo, end:ro, token:left }})            
    }          
    }
}

Vector: Object = {
    <lo:@L> <left: "#("> <objects: Datum *>  <right: ")"> <ro:@R> =>? {
        if (left.eq("#(") && right.eq(")")) || (left.eq("#[") && right.eq("]")) {          
            Ok(gc.new_vector(&objects))
    } else {
        Err(ParseError::User {
            error:ReadError::UnmatchedParen { start:lo, end:ro, token:left }})            
    }          
    }
}

Abbreviation: Object = {
    "'" <datum: Datum> => {
        let quote = gc.symbol_intern("quote");
        gc.list2(quote, datum)
    },
    "`" <datum: Datum> => {
        let quote = gc.symbol_intern("quasiquote");
        gc.list2(quote, datum)
    },
    "," <datum: Datum> => {
        let quote = gc.symbol_intern("unquote");
        gc.list2(quote, datum)
    },
    ",@" <datum: Datum> => {
        let quote = gc.symbol_intern("unquote-splicing");
        gc.list2(quote, datum)
    },
    "#'" <datum: Datum> => {
        let quote = gc.symbol_intern("syntax");
        gc.list2(quote, datum)
    },
    "#`" <datum: Datum> => {
        let quote = gc.symbol_intern("quasisyntax");
        gc.list2(quote, datum)
    },
    "#," <datum: Datum> => {
        let quote = gc.symbol_intern("unsyntax");
        gc.list2(quote, datum)
    },
    "#,@" <datum: Datum> => {
        let quote = gc.symbol_intern("unsyntax-splicing");
        gc.list2(quote, datum)
    },
}

Regexp: Object = {
    // todo
    "regexp" => gc.new_string(&<>),
}


String: Object = {
    "string" => gc.new_string(&<>),
}

Character: Object = {
    "character" => Object::Char(<>),
}


Symbol: Object = {
    "identifier" =>? {
        match reader_util::read_symbol(&<>) {
            Ok(s) => Ok(gc.symbol_intern(&s)),
            Err(err) => {
                Err(ParseError::User {
                    error: ReadError::SymbolParseError { token: <>, description: err.to_string() }})
            }
        }
    }
}

Number: Object = {
    <s: "number10"> =>? reader_util::read_number(gc, &s),
    <s: "number8"> =>? reader_util::read_number(gc, &s),
    <s: "number2"> =>? reader_util::read_number(gc, &s),
    <s: "number16"> =>? reader_util::read_number(gc, &s),
}

Boolean: Object = {
    "true" => Object::True,
    "false" => Object::False,
}

extern {
    type Location = usize;
    type Error = ReadError;

    enum lexer::Token {
        "'" => lexer::Token::AbbrevQuote,
        "`" => lexer::Token::AbbrevQuasiquote,
        "," => lexer::Token::AbbrevUnquote,
        ",@" => lexer::Token::AbbrevUnquoteSplicing,
        "#'" => lexer::Token::AbbrevSyntax,
        "#`" => lexer::Token::AbbrevQuasisyntax,
        "#," => lexer::Token::AbbrevUnsyntax,
        "#,@" => lexer::Token::AbbrevUnsyntaxSplicing,
        "#;" => lexer::Token::DatumComment,
        "#u8(" => lexer::Token::ByteVectorStart { value: <String> },
        "." => lexer::Token::Dot,
        "true" => lexer::Token::True,
        "false" => lexer::Token::False,
        "(" => lexer::Token::LeftParen { value: <String> },
        ")" => lexer::Token::RightParen { value: <String> },
        "#(" => lexer::Token::VectorStart { value: <String> },
        "character" => lexer::Token::Character { value: <char> },
        "identifier" => lexer::Token::Identifier { value: <String> },
        "number10" => lexer::Token::Number10 { value: <String> },
        "number8" => lexer::Token::Number8 { value: <String> },
        "number2" => lexer::Token::Number2 { value: <String> },
        "number16" => lexer::Token::Number16 { value: <String> },
        "regexp" => lexer::Token::Regexp { value: <String> },
        "string" => lexer::Token::String { value: <String> },
        "#1=" => lexer::Token::DefiningShared { value: <String> },
        "#1#" => lexer::Token::DefinedShared { value: <String> },
    }
}