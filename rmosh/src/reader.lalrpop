use std::str::FromStr;
use crate::objects::Object;
use crate::gc::Gc;
use crate::lexer;

grammar(gc: &mut Box<Gc>);

//Num: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();

// R7RS small 7.1.2. External representations
pub Datum: Object = {
    SimpleDatum,
}

SimpleDatum: Object = {
    Boolean,
    //Symbol,
}

//Symbol: Object = {
  //  <Identifier>
//}


// R7RS small 7.1.1. Lexical structure.
//VerticalLine: String = {
   //"|" => <>.to_string()
//}

//Identifier: Object = {
    //<i:Initial> <s:Subsequent *> => gc.symbol_intern(&(i + &s.join(""))),   
    // todo right hand side
   // <v1:VerticalLine> <s:SymbolElement *> <v2:VerticalLine> => gc.symbol_intern(&s.join("")),  
//}

// r"[!$%&*/:<=>?~^_]" precdences over r"[^|/]".
//match {
//    r"[!$%&*/:<=>?~^_]",
    //r"[^|/]",    
//} else {
//
    //r"[A-Za-z]",
//    _
//    
//}

//〈initial〉 −→ 〈letter〉 | 〈special initial〉
//Initial: String = {
  //  <Letter>,
//    <SpecialInitial>,
//}

//〈letter〉 −→ a | b | c | ... | z | A | B | C | ... | Z
//Letter: String = {
  //  r"[A-Za-z]" => <>.to_string()
//}

//〈special initial〉 −→ ! | $ | % | & | * | / | : | < | = | > | ? | ^ | _ | ~
//SpecialInitial: String = {
    //r"[!$%&*/:<=>?~^_]" => <>.to_string()
//}

//〈subsequent〉 −→ 〈initial〉 | 〈digit〉|〈special subsequent〉
//Subsequent: String = {
    //<Initial>,
    //<Digit>,
    //<SpecialSubsequent>,
//}

//〈digit〉 −→ 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
//Digit: String = {
    //r"[0-9]" => <>.to_string()
//}

//〈hex digit〉 −→ 〈digit〉 | a | b | c | d | e | f
//HexDigit: String = {
    //<Digit>,
//    r"[a-f]" => <>.to_string()
//}

//〈explicit sign〉 −→ + | -
//ExplicitSign: String = {
//    r"\+|-" => <>.to_string()
//}

//〈special subsequent〉 −→ 〈explicit sign〉 | . | @
//SpecialSubsequent: String = {
//    <ExplicitSign>,
//    r"[.@]" => <>.to_string()
//}

//〈inline hex escape〉 −→ \x〈hex scalar value〉
//InlineHexEscape: String = {
//    "\\x" <HexScalarValue>,
//}

//〈hex scalar value〉 −→ 〈hex digit〉
//HexScalarValue: String = {
//    <h:HexDigit +> => h.join("")
//} 

//〈mnemonic escape〉 −→ \a | \b | \t | \n | \r
//MnemonicEscape: String = {
//    r"\\a|b|t|n|r" => <>.to_string(),
//}

//〈any character other than 〈vertical line〉 or \〉|〈inline hex escape〉 | 〈mnemonic escape〉 | \|
//SymbolElement: String = {
//    r"[^|/]" => <>.to_string(),
//    <InlineHexEscape>,
//    <MnemonicEscape>,
 //   "\\|" => <>.to_string(),
//}

Boolean: Object = {
    //"#t" => Object::True,
    //"#true" => Object::True,
    //"#f" => Object::False,
    //"#false" => Object::False,
    "token:true" => Object::True,
    "token:false" => Object::False,    
}

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Token {
        "token:true" => lexer::Token::True,
        "token:false" => lexer::Token::False,        
//        "#true" => lexer::Token::True,        
        //"#f" => lexer::Token::False,
  //      "#false" => lexer::Token::False,        
        //"error" => lexer::Token::Error,
    }
}