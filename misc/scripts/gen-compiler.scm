(import (rnrs)
        (match)
        (mosh)
        (mosh control)
        (only (srfi :1) first second third)
        (only (mosh pp) pp))


(define (map-with-index f l)
  (define (iter f l i)
    (if (null? l)
        l
        (cons (f i (car l)) (iter f (cdr l) (+ i 1)))))
  (iter f l 0))


(define (file->list proc pth)
  (with-input-from-file
    pth
    (lambda ()
      (define (itr cur)
        (let ((r (proc (current-input-port))))
          (if (eof-object? r)
            (reverse cur)
            (itr (cons r cur)))))
      (itr '()))))

(define (file->sexp-list pth)
  (file->list read pth))

(define (extract-quasiquote-vector obj)
  (match obj
  (('define (name . args) ('quasiquote #(pat ...)))
   `(define (,name ,@args)
      (let1 v (make-vector ,(length pat))
        ,@(map-with-index
           (lambda (i x)
             `(vector-set! v ,i ,(if (pair? x) (second x) x)))
           pat)
        v)))
  (else
   obj)))

(define (write-cond-expand body)
  (for-each
   (lambda (x)
     (match x
       [('include file-name)
        (for-each pp (file->sexp-list file-name))]
       [else (pp x)]))
   body))

(define (parse-body* body* feature)
  (match body*
    [() (error 'parse-body* (format #f "condition? ~a not found " feature))]
    [(('else . body) . more)
      (write-cond-expand body)]
    [(((? symbol? target) . body) . more)
      (if (eq? target feature)
        (write-cond-expand body)
        (parse-body* more feature))]))

(define (main args)
  (format #t ";; Do not edit this file generated by ~a.\n" (first args))
  (with-input-from-file (second args)
    (lambda ()
      (let loop ([obj (read)])
        (cond
         [(eof-object? obj) '()]
         [else
          (match obj
            [('cond-expand . body*)
              (parse-body* body* (string->symbol (third args)))]
            [else (pp (extract-quasiquote-vector obj)) (newline)])
          (loop (read))]))))
  0)

(main (command-line))

;; (define (main args)
;;   (format #t ";; Do not edit this file generated by ~a.\n" (first args))
;;   (with-input-from-file (second args)
;;     (lambda ()
;;       (let loop ([obj (read)])
;;         (cond
;;          [(eof-object? obj) '()]
;;          [else
;;           (if (and (pair? obj) (eq? 'cond-expand (first obj)))
;;               (begin
;;                 (for-each write  (cdr (find (lambda (x) (eq? (car x) (string->symbol (third args)))) (cdr obj)))))
;;               (write (extract-quasiquote-vector obj)))
;;           (loop (read))]))))
;;   0)
